/*最长上升子序列LIS
	给一个序列, 求满足的严格递增的子序列的最大长度(或者子序列)
	标签: dp
	做法: dp[i]表示长度为i的子序列在第i位的最小值, 每次更新时, 找到最大的k使$dp[k] \leq a_i$, 将dp[k+1]的值更新为$a_i$.
	可以用pre数组存储第i个数的最长子序列的前一个数.
*/
/*两个互不覆盖的最长上升子序列
	给一个序列, 要求找到两个互不覆盖的最长上升子序列, 使其长度之和最大. ($n \leq 1000$)
	标签: 二维dp, 树状数组优化
	做法: dp[l][r]表示第一个串以l结尾, 第二个串以r结尾的最大长度和, 转移方程: @$$
		dp[i][u] = \max{\{dp[i][j]\}} + 1 (1 \leq j < u) $$@, @$$
		dp[u][j] = \max{\{dp[i][j]\}} + 1 (1 \leq i < u) $$@.然后用多个树状数组维护区间最大值.
*/
/*二维偏序的LIS
	给一个二维坐标(x,y)的序列, 求满足对任意i<j, 都有$x_i < x_j, y_i < y_j$的最长子序列
	做法: 二分 + 树状数组 + dp (cdq)
	将序列[l, r]二分, 先处理左边的区间[l, mid],
	再用左边的区间更新右边的区间, 即将区间[l,r]按左端点排序, 然后依次扫描, 遇到在左半区间的加入树状数组, 遇到在右半区间的查询比当前y值更小的数对数并更新, 然后再递归处理右边的区间[mid+1, r]
*/
