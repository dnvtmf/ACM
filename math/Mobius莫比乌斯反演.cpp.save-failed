///莫比乌斯反演 Mobius
//mobius函数
/*@$$ \mu(x) = \left\{ \begin{array}{l l}
		1 & x= 1\\
		(-1)^r & x = p_1 \cdot p_2 \cdots p_r, \mbox{其中}p_i(i = 1, 2, \cdots r)\mbox{是素数}\\
		0 &\mbox{其他}
		\end{array} \right.$$@
*/
//莫比乌斯反演
//@$$ F(n) = \sum_{d|n}{f(d)} \Leftrightarrow f(n) = \sum_{d|n}{\mu (d) F(\frac{n}{d})}	$$@
//@$$\sum_{d|n}{\mu(d)} = \left\{ \begin{array}{l l} 1 &n=1 \\ 0 & n \neq 1\end{array} \right. $$@
//$\displaystyle\sum_{d|n}{\phi(d)} = n, \phi(d)$为欧拉函数
//$\displaystyle \phi(n) = n\sum_{d|n}{\mu(d)/d}$

//使用1
/*
	$\displaystyle \sum{gcd(i, j) == D} (1 \leq i \leq a, 1 \leq j \leq b, a \leq b)$, 即求gcd(i, j)等于d的对数
	$\lfloor x \rfloor$表示下取整
	@$$\sum_{i=1}^{a}{\sum_{j=1}^{b}{gcd(i,j) == D}}$$@
	@$$\Rightarrow \sum_{i=1}^{\lfloor \frac{a}{D} \rfloor}{\sum_{j=1}^{\lfloor \frac{b}{D} \rfloor}{gcd(i, j) == 1}}$$@
	@$$\Rightarrow \sum_{i=1}^{\lfloor \frac{a}{D} \rfloor}{\sum_{d|gcd(i,j)}{\mu(d)}}}$$@, 使用mobius函数和的性质替换gcd(i, j)==1
==> sum(d=1 -> [a/D]){μ(d)*[[a/D]/d]*[[b/D]/d]},  d|gcd(i, j) <==> d|i && d|j
//D == 1, sum(d=1 -> a){μ(d)*[a/d]*[b/d]}
*/

//使用2
/*
	sum(i=1 -> a){sum(j=1 -> b){gcd(i, j)}},(a <= b)
==> sum(d=1 -> a){sum(i=1 -> [a/d]){sum(j=1 -> [b/d]){d*gcd(i, j) ==1}}}
==> sum(d=1 -> a){sum(d'=1 -> [a/d]){d*μ(d')*[a/dd']*[b/dd']}}, 使用1
==> sum(d=1 -> a){sum(d|D){d*μ(D/d)*[a/D]*[b/D]}}, D = d*d'
==> sum(D=1 -> a){[a/D]*[b/D]*(id*μ)(D)}
==> sum(D=1 -> a){[a/D]*[b/D]*φ(D)}, id*μ=φ
*/

///积性函数
//定义在正整数集上的函数f(n)（称为算术函数），若gcd(a, b) = 1时有f(a)f(b) = f(ab)，则称f(x)为积性函数。
//一个显然的性质：（非恒等于零的）积性函数f(n)必然满足f(1)=1。
//定义逐点加法(f + g)(n) = f(x)+g(x), f(x*g) = f(x)*g(x)。
//一个比较显然的性质：若f,g均为积性函数，则f*g也是积性函数。
//积性函数的求值：n = mult{pi^ai}，则f(n) = mult{f(pi^ai)}，所以只要解决n = p^a时f(n)的值即可。

//常见积性函数有：
//恒为1的常函数1(n) = 1，
//恒等函数id(n) = n，
//单位函数ε(n) = (n==1)，（这三个都是显然为积性）
//欧拉函数φ(n) （只要证两个集合相等就能证明积性）
//莫比乌斯函数μ(n) （由定义也是显然的）
//μ*id = φ
void pre_mobius()
{
    mu[1] = 1;
    for(int i = 2; i < NUM; i++)
        if(!mu[i])
        {
            mu[i] = -1;
            for(int j = i + i; j < NUM; j += i)
                if((j / i) % i == 0)
                    mu[j] = 2;
                else
                {
                    if(mu[j] == 0) mu[j] = -1;
                    else mu[j] = -mu[j];
                }
        }
        else if(mu[i] == 2 || mu[i] == -2) mu[i] = 0;
}
