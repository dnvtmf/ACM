1. 字符串A的任意子串x和字符串B的任意子串y(x, y可以为空)形成一个新的字符串xy, 能构成多少种字符串?
	来源: hdu5344, 2015多校第5场1001
	做法: 问题关键在于去重. 答案为: A中不同子串的个数 $\times$ B中不同子串的个数 - $\sum_{c = 'a'}^{'z'}$(A中以字符c结尾的不同子串数 * B中以字符c开头的不同子串数). 将A反转, 然后用后缀数组维护A, B中不同子串的个数, 和以某字符开头的不同子串数即可. 答案会爆long long, 要用unsigned long long
	
2. 求后缀数组中, 某一子串S[l, r]出现的首次出现的位置, 或者最后出现的位置, 或者求某一公共子串出现的次数
	标签: ST表, 二分
	做法: 用ST表预处理高度数组, 那么可以在O(1)时间内求出任意两个后缀之间的最长公共前缀; 在某后缀后面(或前面)的后缀与该后缀的lcp是非增(非减)的, 因此可以用二分求出距该后缀最远的一个与该后缀有最长公共前缀长度大于等于len的后缀.
	
3. 询问一个字符串S中, 比某子串S[L, R]字典序小的子串数.
	来源: Gym 100418C
	标签: 后缀数组, 二分, 区间更新查询
	做法: 将查询离线处理, 用二分得到每个被询问的子串在后缀数组中第一次出现的位置, 然后按照后缀的字典序遍历, (即遍历后缀数组) 得到比每个后缀小的子串数, 在此过程中, 处理询问的答案. 比某个后缀小的子串数, 为不是该后缀的前缀, 但比该后缀小的子串数 + 是该后缀的前缀的子串数. 处理时, 随高度数组处理, 有前缀长度为i(i= 0, 1, 2, $\cdots$, height[i +1]), 比该后缀小的子串数. 直接处理会超时, 要用线段树更新和查询区间.

4. 求有多少个z, 使得由$z = (z \cdot a + c) / k (\% m)$产生的一个长度为n的数字序列, 将小于m/2的数字标记为0, 其他的标记为1后与目标串b相同.
	来源: Gym 100523G
	标签: hash, 倍增
	做法: 分析生成函数, 可以发现这是一个有m个状态的有限状态自动机, 然后可以在$O(m)$时间内求出每个状态将会转移到的下一个状态. 类似于ST表的思想, 我们预处理出从每个状态出发, 长度为2的幂的生成字符串的hash值, 并保存下一个会转移到的位置. 就有转移方程: $hash[i][j] = hash[i][j-1] \times B[1 << (j - 1)] + hash[pos[i][j - 1]][j - 1], pos[i][j] = pos[pos[i][j - 1]][j - 1]$, 然后我们就可以在$O(m\log{n})$时间内求出每个z出发, 长度为n的生成字符串的hash值, 然后与目标串b的hash值比较, 然后统计即可. 然而, 由于内存限制, 我们要用滚动数组预处理, 并在此过程中求出长度为n的生成字符串的hash值.
	时间复杂度: $O{m\log{n}}$