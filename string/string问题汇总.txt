1. 字符串A的任意子串x和字符串B的任意子串y(x, y可以为空)形成一个新的字符串xy, 能构成多少种字符串?
	来源: hdu5344, 2015多校第5场1001
	做法: 问题关键在于去重. 答案为: A中不同子串的个数 * B中不同子串的个数 - $\sum_{c = 'a'}^{'z'}$(A中以字符c结尾的不同子串数 * B中以字符c开头的不同子串数). 将A反转, 然后用后缀数组维护A, B中不同子串的个数, 和以某字符开头的不同子串数即可. 答案会爆long long, 要用unsigned long long
	
2. 求后缀数组中, 某一子串S[l, r]出现的首次出现的位置, 或者最后出现的位置, 或者求某一公共子串出现的次数
	标签: ST表, 二分
	做法: 用ST表预处理高度数组, 那么可以在O(1)时间内求出任意两个后缀之间的最长公共前缀; 在某后缀前面(或前面)的后缀与该后缀的lcp是非增的, 因此可以用二分求出距该后缀最远的一个与该后缀有最长公共前缀长度大于等于len的后缀.
	
3. 询问一个字符串S中, 比某子串S[L, R]字典序小的子串数.
	来源: Gym 100418C
	标签: 后缀数组, 二分, 区间更新查询
	做法: 将查询离线处理, 用二分得到每个被询问的子串在后缀数组中第一次出现的位置, 然后按照后缀的字典序遍历, (即遍历后缀数组) 得到比每个后缀小的子串数, 在此过程中, 处理询问的答案. 比某个后缀小的子串数, 为不是该后缀的前缀, 但比该后缀小的子串数 + 是该后缀的前缀的子串数. 处理时, 随高度数组处理, 有前缀长度为i(i= 0, 1, 2, $\cdots$, height[i +1]), 比该后缀小的子串数. 直接处理会超时, 要用线段树更新和查询区间.
	